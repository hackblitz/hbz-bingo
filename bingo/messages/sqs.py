import json
import logging
import os
from datetime import datetime
from typing import Dict

import boto3
import botocore

logger = logging.getLogger(__name__)


class SQSMeta(type):
    def __new__(mcs, name, bases, attrs):
        queue_name = attrs.get("name")

        if not queue_name and name != "SQSQueue":
            raise NotImplementedError(
                f"SQSQueue <{name}> incomplete. Missing attribute (name -> SQS queue name)."
            )

        cls = super().__new__(mcs, name, bases, attrs)

        if name != "SQSQueue":
            setattr(cls, "__client__", boto3.client("sqs"))

            try:
                response = cls.__client__.get_queue_url(QueueName=f"bingo_{queue_name}")
            except botocore.exceptions.ClientError as e:
                if (
                    e.response["Error"]["Code"]
                    == "AWS.SimpleQueueService.NonExistentQueue"
                ):
                    response = cls.__client__.create_queue(
                        QueueName=f"bingo_{queue_name}",
                        Attributes={
                            "ReceiveMessageWaitTimeSeconds": "20",
                            "VisibilityTimeout": "60",
                        },
                        tags={
                            "Owner": "bingo",
                            "Created": datetime.now().isoformat(),
                            "Maintainer": os.getenv(
                                "BINGO_SERVICE_NAME", "hackblitz/bingo"
                            ),
                            "DEAD_LETTER_QUEUE_NAME": f"bingo_dlq_{queue_name}",
                        },
                    )

            setattr(cls, "__url__", response["QueueUrl"])

            try:
                response = cls.__client__.get_queue_url(
                    QueueName=f"bingo_dlq_{queue_name}"
                )
            except botocore.exceptions.ClientError as e:
                if (
                    e.response["Error"]["Code"]
                    == "AWS.SimpleQueueService.NonExistentQueue"
                ):
                    response = cls.__client__.create_queue(
                        QueueName=f"bingo_dlq_{queue_name}",
                        Attributes={
                            "ReceiveMessageWaitTimeSeconds": "5",
                            "VisibilityTimeout": "60",
                        },
                        tags={
                            "Owner": "bingo",
                            "Created": datetime.now().isoformat(),
                            "Maintainer": os.getenv(
                                "BINGO_SERVICE_NAME", "hackblitz/bingo"
                            ),
                            "ORIGIN_QUEUE_NAME": f"bingo_{queue_name}",
                        },
                    )

            setattr(cls, "__dlq_url__", response["QueueUrl"])

        return cls


class SQSQueueSendPriority:
    HIGH = 0
    MEDIUM = 10
    LOW = 15


class SQSQueue(metaclass=SQSMeta):
    """
    Class to send/receive message via AWS SQS service.
    """

    PRIORITY = SQSQueueSendPriority.HIGH
    BATCH_SIZE = 1
    PRIORITIES = SQSQueueSendPriority

    @classmethod
    def send(cls, message: Dict, priority: int = PRIORITY) -> str:
        """
        Send message to a SQS queue

        Args:
            message (dict)
            priority (int)

        Returns:
            str -> MessageId generated by SQS

        Refer:
            * messags.sqs.SQSQueueSendPriority -> to know about the priorities in detail.
        """

        response = cls.__client__.send_message(
            QueueUrl=cls.__url__, MessageBody=json.dumps(message), DelaySeconds=priority
        )
        return response["MessageId"]

    @classmethod
    def receive(cls) -> None:
        """
        Receive message(s) from a SQS queue. This sends the message to
        dead letter queue if there is any exception when processing the message
        with the handler.

        Note:
            * The messages received will be removed from the SQS queue.
            * Use BATCH_SIZE attribute in the class to tune to max number of messages in each receive.

        Raises:
            Exception
        """

        response = cls.__client__.receive_message(
            QueueUrl=cls.__url__,
            AttributeNames=["SentTimestamp"],
            MaxNumberOfMessages=cls.BATCH_SIZE,
            MessageAttributeNames=["All"],
            WaitTimeSeconds=5,
        )

        for message in response.get("Messages", []):
            cls.__client__.delete_message(
                QueueUrl=cls.__url__, ReceiptHandle=message["ReceiptHandle"]
            )

            try:
                cls.message_handler(json.loads(message["Body"]))
            except Exception as exception:
                try:
                    cls.error_handler(exception)
                except:
                    pass

                cls.__client__.send_message(
                    QueueUrl=cls.__dlq_url__, MessageBody=message["Body"]
                )

    @classmethod
    def poll(cls) -> None:
        """
        Receive messages from SQS queue in realtime
        """

        while True:
            try:
                cls.receive()
            except KeyboardInterrupt:
                logger.info(f"Stopping poll from {cls.__name__} to queue {cls.name}")
                break
            except Exception as exception:
                cls.error_handler(exception)

    @classmethod
    def error_handler(cls, exception: Exception) -> None:
        """
        Handles the errors when processing the received message.
        """

        logging.error(exception)

    @classmethod
    def message_handler(cls, message: Dict) -> None:
        """
        Process the received message. Implement this in the actual class to
        receive messages.

        Args:
            message (dict)

        Raises:
            NotImplementedError -> if the method is not present in the acutal class
        """

        raise NotImplementedError(
            f"Message handler not implemented. Received message {str(message)}."
        )
